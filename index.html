<!DOCTYPE html>
<html>
  <head>
    <title>How we use Scala</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.5em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
layout: true
class: center, middle
---
# How we use Scala
.footnote[Viaƒçeslav Pozdniakov, Adform]

---
layout: false
# I this talk I will...
.left-column[
  ## ...speak about DCO
]
.right-column[

- What is that

- Why this might be called "Big Data"

- Challenges we have

- The way we solve them

]
---
layout: false
# I this talk I will...
.left-column[
  ## ...speak about DCO
  ## ...not speak about _all_ Scala we have
]
.right-column[

- Spark

- Scalding

- Scalaz-stream

- ... any other cool stuff

]

---
# DCO
.left-column[
  ## Reference
]
.right-column[

- Dynamic creative optimization 

- _or_

]

---
# DCO
.left-column[
  ## Reference
]
.right-column[

- Dynamic creative optimization 

- _or_ Dynamic content optimization 

]
---
# DCO
.left-column[
  ## Reference
  ## Which means
]
.right-column[

We are optimizing a content of banners especially for you based on what we know about you.
]

---
# DCO
.left-column[
  ## Reference
  ## Which means
  ## We work with
]
.right-column[

Two things only:

- Data about everyone we have ever met (profile)

- Products all these good people might be interested in

]
---
# DCO
.left-column[
  ## Reference
  ## Which means
  ## We work with
]
.right-column[

Two things only:

- Data about everyone we have ever met (profile)

- Products all these good people might be interested in

So, we are not evil :)

]
---
# DCO
.left-column[
  ## Reference
  ## Which means
  ## We work with
  ## Requirements
]
.right-column[

- < 100ms

- highly available

- scalable

]
---
# Storage
.left-column[
  ## Cassandra
]
.right-column[

Users' profiles:

- _A lot_ of data

- Fast access

- Clustered

- Monitoring

- Great drivers

- Written in Java :)

- Runs on any hardware

]
---
# Storage
.left-column[
  ## Cassandra
  ## Redis
]
.right-column[

Products:

- Not that much data

- Operations on sets: intersections, diffs

- Very fast

- _but_

]
---
# Storage
.left-column[
  ## Cassandra
  ## Redis
]
.right-column[

Products:

- Not that much data

- Operations on sets: intersections, diffs

- Very fast

- _but_ choosy, requires a lot of tuning before giving awesome results

]
---
# Cool stuff
.left-column[
  ## We code
]
.right-column[

- Twitter's Finagle

- Twitter's futures

- Cassandra Datastax Java drivers (Google's futures)

- And, _sure_

]
---
# Cool stuff
.left-column[
  ## We code
]
.right-column[

- Twitter's Finagle

- Twitter's futures

- Cassandra Datastax Java drivers (Google's futures)

- And, _sure_, we have Akka

- ... and Spray
]
---
# Cool stuff
.left-column[
  ## We code
  ## We test
]
.right-column[

- Scalatest

- Finagle is awesome for testing

- Scalacheck

]
---
# Finagle
.left-column[
  ## Pure
]
.right-column[
Your server is a function:
```{.scala}
(Request => Future[Response])
```

As simple as that!
]
---
# Finagle
.left-column[
  ## Pure
  ## Awesome
]
.right-column[
Why so awesome?

```{.scala}
test("delete profile") {
  val service = mock[Service]
  service.deleteProfile(123456789) returns Future()
  val resource = new ProfileResource(service)

  val request = Request(DELETE, "/?c=123456789&s=123")

  val response = Response(Await.result(resource(request)))

  response.status should equal (OK)
  verify(service).deleteProfile(123456789)
}
```
]
---
# Non-blocking at all
.left-column[
  ## Async
]
.right-column[
All internals (layers) must be asynchronous:

- Finagle's resource gets params and calls service, service immediately returns Future of a result

- Service gets params, performs some BL, calls repository and immediately return Future of a result

- Repositiry gets params, calls storage's driver which immediately returns (Google's) Future of a result (implicit magic):

```{.scala}
val rs:ResultSetFuture = session.executeAsync(statement)
```

Everything is glued up via _map_, _flatMap_ and Future's helping methods like _join_. Fanagle handles everything.
]
---
# Non-blocking at all
.left-column[
  ## Async
  ## Not async
]
.right-column[

But not all drivers a non-blocking. We have Redis, remember? ;)

- Redis is multiplexing, like Node.js

- Most drivers are blocking

- Even the best ones, like Jedis

Twitter's Future pool saves the day:
```{.scala}
val futurePool: ExecutorServiceFuturePool =
  FuturePool.unboundedPool
val result: Future[Long] =
  futurePool(jedisPool.getResource.scard("key"))
```
Call-by-name parameters save many lines of code:
```{.scala}
def apply[T](f: => T): Future[T]
```
]
---
# ScalaCheck
.left-column[
  ## It's hard
]
.right-column[

- Writing property tests is easy for mappers only

- Property testing of business logics is difficult

- Especially with multiple parameters
]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
]
.right-column[
No! It is not _just_ difficult. Sometimes it:

  - makes you hopeless

  - and depressed

We have already rewritten our scalacheck tests for 3 times because of a very high entry level.
]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
]
.right-column[
No! It is not _just_ difficult. Sometimes it:

  - makes you hopeless

  - and depressed

We have already rewritten our scalacheck tests for 3 times because of a very high entry level.

I know I work for a great company ;)
]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
  ## Be rewarded
]
.right-column[

- Catches almost all corner cases

- And not only corner cases

]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
  ## Be rewarded
]
.right-column[

- Catches almost all corner cases

- And not only corner cases

- Finally, tests say how a code works:

```{.scala}
testCaseWithResult => {
  val recommendedIds = testCaseWithResult.products.ids
  recommendedIds should equal(recommendedIds.distinct)
}```
]
---
# Spray.io
.left-column[
  ## Upload
]
.right-column[
We use it as a server side for XML upload

- Chunked upload

- Huge files (gigabytes, potentialy unlimited)

- Finds and processes data on the fly

- And, _once again_
]
---
# Spray.io
.left-column[
  ## Upload
]
.right-column[
We use it as a server side for XML upload

- Chunked upload

- Huge files (gigabytes, potentialy unlimited)

- Finds and processes data on the fly

- And, _once again_, non-blocking
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
]
.right-column[
```{.xml}
<root
```
```{.xml}
>
  <tag>
    <data 
```
```{.xml}
a="d"/>
  </tag>
```
```{.xml}
</root>
```
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
]
.right-column[
Current situation:

- There are a lot of pull-parsers for jvm

- But all of them are blocking:

  - You subscribe to events (which seems to be asynchronous behaviour)

  - _But_,
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
]
.right-column[
Current situation:

- There are a lot of pull-parsers for jvm

- But all of them are blocking:

  - You subscribe to events (which seems to be asynchronous behaviour)

  - _But_, source of data is blocking: InputStream, File, ...
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
  ## Aalto
]
.right-column[
Aalto parser (half a year ago) was the only stax parser in jvm world which can be used in non-blocking xml parsing.

Asynchronousness is achieved by:

- Method _feedInput_ providing an array of newly available data

- Parse event EVENT_INCOMPLETE, signaling that it is not enough data for parser at the moment
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
  ## Aalto
  ## Too stateful
]
.right-column[

Parser can be:
- Not yet parsing

- Parsing (consuming pull events)

- Failed (illegal xml)

- Waiting for input

- Everything is parsed

Data (chunks):

- Arriving

- Temporary stopped

- Permanently stopped

]
---
# Akka
.left-column[
  ## Rule
]
.right-column[

Rule of thumb:

- If you have a lot of states &mdash; use actor model.

- If app is not too stateful &mdash; you do not need actors

]
---
# Akka
.left-column[
  ## Rule
  ## Advise
]
.right-column[

Akka does not eliminate states, it just makes it easier to handle

- Use Finite State Machine

- Or become/unbecome

]
---
# Akka
.left-column[
  ## Rule
  ## Advise
  ## Transitions
]
.right-column[

If you are waiting for chunk, and:

- Get new chunk, then collect it

- Get a flag of last chunk, then go to finite state

- Get a flag that a parser needs more data, then go to starvation state

```{.scala}
private def receivingChunksState(): Receive = {
  case m: MessageChunk =>
    bytes = bytes ++ m.data.toByteString
  case ChunkedMessageEnd =>
    context.become(noMoreChunks)
  case MoreDataNeeded =>
    if (bytes.nonEmpty) feedAll()
    else context.become(starving, discardOld = false)
}
```
]
---
# Akka
.left-column[
  ## Rule
  ## Advise
  ## Transitions
]
.right-column[
If you are in starvation state, and:

- Get new chunk, then send it to parser and get back to previous state

- Get a flag of last chunk, then signal a parser and got to finite state

```{.scala}
private def starvingState(): Receive = {
  case m: MessageChunk =>
    parser ! FeedData(m.data.toByteString)
    context.unbecome()
  case ChunkedMessageEnd =>
    parser ! NoMoreDataAvailable
    context.become(finalizing)
}
```
]
---
# Conclusion
.left-column[
  ## Scala
]
.right-column[

- We do serious things with Scala

- Is is already mature, there is nothing to wait for

]
---
# Conclusion
.left-column[
  ## Scala
  ## Other
]
.right-column[
Yes, we are fans but not fanboys.

We also have (in our team):

- Python

- Javascript / Node.js

- Bash

- C#

- Java libraries, if they are good

- And even Haskell 
]
---
# Conclusion
.left-column[
  ## Scala
  ## Other
  ## Advice
]
.right-column[
You can use any programming language
]
---
# Conclusion
.left-column[
  ## Scala
  ## Other
  ## Advice
]
.right-column[
You can use any programming language as long as it's Scala :)
]
---
layout: true
class: center, middle

# Thank you!

## @poznia

## http://github.com/vipo/how_we_use_scala

---
    </textarea>
    <script src="remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>