<!DOCTYPE html>
<html>
  <head>
    <title>How we use Scala</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.5em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
layout: true
class: center, middle
---
# How we use Scala
.footnote[Viačeslav Pozdniakov, Adform]

---
layout: false
# I this talk I will...
.left-column[
  ## ...speak about DCO
]
.right-column[

- What is that

- Why this might be called "Big Data"

- Challenges we have

- The way we solve them

]
---
layout: false
# I this talk I will...
.left-column[
  ## ...speak about DCO
  ## ...not speak about _all_ Scala we have
]
.right-column[

- Spark

- Scalding

- Scalaz-stream

- ... any other cool stuff

]

---
# DCO
.left-column[
  ## Reference
]
.right-column[

- Dynamic creative optimization 

- _or_

]

---
# DCO
.left-column[
  ## Reference
]
.right-column[

- Dynamic creative optimization 

- _or_ Dynamic content optimization 

]
---
# DCO
.left-column[
  ## Reference
  ## Which means
]
.right-column[

We are optimizing a content of banners especially for you based on what we know about you.
]

---
# DCO
.left-column[
  ## Reference
  ## Which means
  ## We work with
]
.right-column[

Two things only:

- Data about everyone we have ever met (profile)

- Products all these good people might be interested in

]
---
# DCO
.left-column[
  ## Reference
  ## Which means
  ## We work with
]
.right-column[

Two things only:

- Data about everyone we have ever met (profile)

- Products all these good people might be interested in

So, we are not evil :)

]
---
# Storage
.left-column[
  ## Cassandra
]
.right-column[

Users' profiles:

- _A lot_ of data

- Fast access

- Clustered

- Monitoring

- Great drivers

- Written in Java :)

]
---
# Storage
.left-column[
  ## Cassandra
  ## Redis
]
.right-column[

Products:

- Not that much data

- Operations on sets: intersections, diffs

- Very fast

- _but_

]
---
# Storage
.left-column[
  ## Cassandra
  ## Redis
]
.right-column[

Products:

- Not that much data

- Operations on sets: intersections, diffs

- Very fast

- _but_ choosy, requires a lot of tuning before giving awesome results

]
---
# Cool stuff
.left-column[
  ## We code
]
.right-column[

- Twitter's Finagle

- Twitter's futures

- Cassandra Datastax Java drivers (Google's futures)

- And, _sure_

]
---
# Cool stuff
.left-column[
  ## We code
]
.right-column[

- Twitter's Finagle

- Twitter's futures

- Cassandra Datastax Java drivers (Google's futures)

- And, _sure_, we have Akka

- ... and Spray
]
---
# Cool stuff
.left-column[
  ## We code
  ## We test
]
.right-column[

- Scalatest

- Finagle is awesome for testing

- Scalacheck

]
---
# Finagle
.left-column[
  ## Pure
]
.right-column[
Your server is a function:
```{.scala}
(Request => Future[Response])
```

As simple as that!
]
---
# Finagle
.left-column[
  ## Pure
  ## Awesome
]
.right-column[
Why so awesome?

```{.scala}
test("delete profile") {
  val service = mock[Service]
  service.deleteProfile(123456789, 123) returns Future()
  val resource = new ProfileResource(service)

  val request = Request(DELETE, "/?c=123456789&s=123")

  val response = Response(Await.result(resource(request)))

  response.status should equal (OK)
  verify(service).deleteProfile(123456789)
}
```
]
---
# Non-blocking at all
.left-column[
  ## Async
]
.right-column[
All internals (layers) must be asynchronous:

- Finagle's resource gets params and calls service, service immediately returns Future of a result

- Service gets params, performs some BL, calls repository and immediately return Future of a result

- Repositiry gets params, calls storage's driver which immediately returns Future of a result:

```{.scala}
val rs:ResultSetFuture = session.executeAsync(statement)
```

Everything is glued up via _map_, _flatMap_ and Future's helping methods like _join_. Fanagle handles everything.
]
---
# Non-blocking at all
.left-column[
  ## Async
  ## Not async
]
.right-column[

But not all drivers a non-blocking. We have Redis, remember? ;)

- Redis is multiplexing, like Node.js

- Most drivers are blocking

- Even the best ones, like Jedis

Twitter's Future pool saves the day:
```{.scala}
val futurePool: ExecutorServiceFuturePool =
  FuturePool.unboundedPool
val result: Future[Long] =
  futurePool(jedisPool.getResource.scard("key"))
```
Call-by-name parameters save many lines of code:
```{.scala}
def apply[T](f: => T): Future[T]
```
]
---
# ScalaCheck
.left-column[
  ## It's hard
]
.right-column[

- Writing property tests is easy for mappers only

- Property testing of business logics is difficult

- Especially with multiple parameters
]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
]
.right-column[
No! It is not _just_ difficult. Sometimes it:

  - makes you hopeless

  - and depressed

We have already rewritten our scalacheck tests for 3 times because of a very high entry level.
]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
]
.right-column[
No! It is not _just_ difficult. Sometimes it:

  - makes you hopeless

  - and depressed

We have already rewritten our scalacheck tests for 3 times because of a very high entry level.

I know I work for a great company ;)
]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
  ## Be rewarded
]
.right-column[

- Catches almost all corner cases

- And not only corner cases

]
---
# ScalaCheck
.left-column[
  ## It's hard
  ## Fail much
  ## Be rewarded
]
.right-column[

- Catches almost all corner cases

- And not only corner cases

- Finally, tests say how a code works:

```{.scala}
testCaseWithResult => {
  val recommendedIds = testCaseWithResult.products.ids
  recommendedIds should equal(recommendedIds.distinct)
}```
]
---
# Spray.io
.left-column[
  ## Upload
]
.right-column[
We use it as a server side for XML upload

- Chunked upload

- Huge files (gigabytes, potentialy unlimited)

- Finds and processes data on the fly

- And, _once again_
]
---
# Spray.io
.left-column[
  ## Upload
]
.right-column[
We use it as a server side for XML upload

- Chunked upload

- Huge files (gigabytes, potentialy unlimited)

- Finds and processes data on the fly

- And, _once again_, non-blocking
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
]
.right-column[
```{.xml}
<root
```
```{.xml}
>
  <tag>
    <data 
```
```{.xml}
a="d"/>
  </tag>
```
```{.xml}
</root>
```
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
]
.right-column[
Current situation:

- There are a lot of pull-parsers for jvm

- But all of them are blocking:

  - You subscribe for events (which seems to be asynchronous behaviour)

  - _But_,
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
]
.right-column[
Current situation:

- There are a lot of pull-parsers for jvm

- But all of them are blocking:

  - You subscribe for events (which seems to be asynchronous behaviour)

  - _But_, source of data is source of blocking: InputStream, File, ...
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
  ## Aalto
]
.right-column[
Aalto parser (half a year ago) was the only stax parser in jvm world which can be used in non-blocking xml parsing.

Asynchronousness is achieved by:

- Method _feedInput_ providing an array of newly available data

- Parse event EVENT_INCOMPLETE, signaling that it is not enough data for parser at the moment
]
---
# Spray.io
.left-column[
  ## Upload
  ## Chunks
  ## Pull parse
  ## Aalto
  ## Too stateful
]
.right-column[

Parser can be:
- Not yet parsing

- Parsing (consuming pull events)

- Failed (illegal xml)

- Waiting for input

- Everything is parsed

Data (chunks):

- Arriving

- Temporary stopped

- Permanently stopped

]
---
# Imperative "for"
.left-column[
  ## Reference
]
.right-column[
It is said:

> A for loop
```{.scala}
for (p <- e) s
```
> is translated to
```{.scala}
e.foreach {case p => s}
```
> And:
```{.scala}
for (p1 <- e1; p2 <- e2) s
```
> is translated to
```{.scala}
e1.foreach {case p1 => for (p2 <- e2) s}
```
]
---
# Imperative "for"
.left-column[
  ## Reference
  ## Magic
]
.right-column[
```{.scala}
for (i <- 1 to 4) {
  println(i)
}
```
which actually is
```{.scala}
for (i <- new Range.Inclusive(1, 4, 1)) {
  println(i)
}
```
because RichInt has
```{.scala}
def to(end: Int): Range.Inclusive =
  Range.inclusive(self, end)
```
and Range has
```{.scala}
def inclusive(start: Int, end: Int): Range.Inclusive =
  new Inclusive(start, end, 1)
```
]
---
# Digression Two
.left-column[
  ## Text
]
.right-column[
Students are suprized by two things:

- List can be empty

- Lists can contain not only numbers or other primitive types, but also
  other "things" like records/structs and objects like "FireExtinguisher"
]
---
# Digression Two
.left-column[
  ## Text
  ## Pic
]
.right-column[
![Job](job.jpg)
]

???

Knowing these two things is quite enough to become a hibernate guru.
---
# Imperative "for"
.left-column[
  ## Reference
  ## Magic
  ## Pffff
]
.right-column[
```{.scala}
case class FireExtinguisher(liters: Int){
  def foreach[T](action: (String) => T) =
    action(s"p${"ff"*liters.max(0)}"): T
}
```
Usage:
```{.scala}
for (sound <- FireExtinguisher(-1)) println(sound)
for {
  sound1 <- FireExtinguisher(1)
  sound2 <- FireExtinguisher(2)
} {
  println(sound1)
  println(sound2)
}
```
Output:
```{.txt}
p
pff
pffff
```
]

???

You can return not only Unit, but also Int or any other type.

---
# For comprehensions
.left-column[
  ## No magic of Map
]
.right-column[
A for comprehension
```{.scala}
for ( p <- e ) yield exp
```
is translated to
```{.scala}
e.map { case p => exp }
```
Map function is well known for such code:
```{.scala}
List(1,2,3).map(v => v.toDouble + 1)

Option(5).map(v => v % 2 == 0)
```
which is evaluated to:
```{.scala}
List(2.0, 3.0, 4.0)
Some(false)
```
]

???

It is kind of natural that mapping over an Option generates for us a new Option, not List

It is natural but not mandatory!

---
# For comprehensions
.left-column[
  ## No magic of Map
  ## Extinguisher
]
.right-column[
Map *can be* used to change a "content" of something
```{.scala}
sealed trait FireClass
case object ClassA extends FireClass
case object ClassB extends FireClass

case class Extinguisher(fireClass: FireClass, liters: Int) {
  def map(f: FireClass => (FireClass, Double)) = {
    val (newFireClass, multiplier) = f(fireClass)
    Extinguisher(newFireClass, (liters * multiplier).toInt)
  }
}
```
So:
```{.scala}
for (fireClass <- Extinguisher(ClassA, 3))
yield
  if (fireClass == ClassB) (fireClass, 1)
  else (ClassB, 1.5)
```
produces:
```{.scala}
Extinguisher(ClassB, 4)
```
]

???

Not so obvious thing to map over
---
# For comprehensions
.left-column[
  ## No magic of Map
  ## Extinguisher
  ## Some magic of flatMap
]
.right-column[
A for comprehension
```{.scala}
for ( p1 <- e1; p2 <- e2 ) yield exp
```
is translated to
```{.scala}
e.flatMap { case p => for ( p2 <- e2 ) yield exp }
```
FlatMap is widely used when you want provide "more" data than map:
```{.scala}
List(10, 20, 30).flatMap(v => List(v, v+1))

Some(5).flatMap(v => Some(v+1)).map(v => v+10)
```
which is evaluated to:
```{.scala}
List(10, 11, 20, 21, 30, 31)
Some(16)
```
]

???

Not a single arrow in for expression

All are flatmaps and last one is map
---
# For comprehensions
.left-column[
  ## No magic of Map
  ## Extinguisher
  ## Some magic of flatMap
  ## Classical magic
]
.right-column[
Calculate all pairs such that both elements are even:
```{.scala}
for {
  a <- List(1, 2, 3, 4, 5, 6, 7)
  b <- List(3, 4, 5, 6)
  p <- if (a % 2 == 0 && b % 2 == 0) List((a, b)) else List()
} yield p
```
produces:
```{.scala}
List((2,4), (2,6), (4,4), (4,6), (6,4), (6,6))
```
Handy implicit "option2Iterable" conversion allow us to achieved same result via:
```{.scala}
for {
  a <- List(1,2,3,4,5,6,7)
  b <- List(3,4,5,6)
  p <- if (a % 2 == 0 && b % 2 == 0) Some((a, b)) else None
} yield p
```
]

???

a, b and p are generators

Branching

Some is a List with single value...
---
# For comprehensions
.left-column[
  ## No magic of Map
  ## Extinguisher
  ## Some magic of flatMap
  ## Classical magic
  ## Big Fire
]
.right-column[
We have a big fire and we need a lot of fire extinguishers at the same time.
Empty ones ruin a whole firefighting operation.
```{.scala}
case class Extinguisher(liters: Int) {
  def map(f: Int => Int) =
    Extinguisher(if(liters == 0) 0 else f(liters))
  def flatMap(f: Int => Extinguisher): Extinguisher =
    if (liters != 0) f(liters)
    else Extinguisher(0)
}
```
So:
```{.scala}
for {
  a <- Extinguisher(20)
  b <- Extinguisher(0)
  c <- Extinguisher(1)
} yield a + b + c
```
produces ```Extinguisher(0)```
]
---
# For comprehensions
.left-column[
  ## Decompose
]
.right-column[
```{.scala}
for {
  a <- Extinguisher(20)
  b <- Extinguisher(1)
  c <- Extinguisher(2)
} yield a + b + c
```
really is
```{.scala}
Extinguisher(20).flatMap(
  a => Extinguisher(1).flatMap(
    b => Extinguisher(2).map(
      c => a + b + c
    )
  )
)
```
Reference:
```{.scala}
def map(f: Int => Int) =
  Extinguisher(if(liters == 0) 0 else f(liters))
def flatMap(f: Int => Extinguisher): Extinguisher =
  if (liters != 0) f(liters)
  else Extinguisher(0)```
]

???

All are flat maps and the last one is map.
---
# For comprehensions
.left-column[
  ## Decompose
  ## Magical If
]
.right-column[
Reference says:
> A generator
```{.scala}
p <- e
```
> followed by a guard ```if g``` is translated to:
```{.scala}
p <- e.withFilter( g )
```
This code:
```{.scala}
for (i <- 0 to 10 if i % 3 == 0) yield i
```
produces
```{.scala}
Vector(0, 3, 6, 9)
```
]

???

withFilter can be replaced by filter
---
# For comprehensions
.left-column[
  ## Decompose
  ## Magical If
  ## Even pairs
]
.right-column[
So this code:
```{.scala}
for {
  a <- List(1, 2, 3, 4, 5, 6, 7)
  b <- List(3, 4, 5, 6)
  p <- if (a % 2 == 0 && b % 2 == 0) List((a, b)) else List()
} yield p
```
can be replaced by:
```{.scala}
for {
  a <- List(1, 2, 3, 4, 5, 6, 7)
  b <- List(3, 4, 5, 6)
  if a % 2 == 0 && b % 2 == 0
} yield (a, b)
```
This shows us that value ```List()``` **is** somehow special.
]

???

failing branch

---
# Digression Three
.left-column[
  ## Text
]
.right-column[
I am pretty sure I have mentioned a word "monad" at least for three times during this talk :)
]
---
# Digression Three
.left-column[
  ## Text
  ## Text Two
]
.right-column[
Definition of a monad for enterprise architects:
> A monad is a design pattern in functional programming.
]
---
# Digression Three
.left-column[
  ## Text
  ## Text Two
  ## Pic
]
.right-column[
![Monad](monad.jpg)
]
---
# A monad as a monoid
.left-column[
  ## Operation
]
.right-column[
It has a single operation with a hidden business rules, like:

- Concatination of lists

- Operations with Optional values

- Composing Futures

- Composing fire extinguisher into a huge one
]
---
# A monad as a monoid
.left-column[
  ## Operation
  ## A zero
]
.right-column[
It has a "zero" - a special value which acts like an "empty" or "terminating" thing:

- Empty list

- None for Option

- Failure for Future

- Empty fire extinguisher
]
---
# A monad as a monoid
.left-column[
  ## Operation
  ## A zero
  ## Intuition
]
.right-column[
If you feel you:

- Have a single business rule in a domain representing class which can produce
a new instance of the class given an old one's data

- Have a special value of this class which acts like a zero in math

- Hava a code which correctly works within _for_ expression

then **probably** you have created a monad. Congrats!
]

???

It still needs to be proved.
---
layout: true
class: center, middle

# Thank you!

github.com/vipo/scala-no-loops
---
    </textarea>
    <script src="remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>